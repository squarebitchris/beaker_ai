# R1-E01-T003 - Background Jobs with Sidekiq

**Status:** ✅ Completed (Migrated from SolidQueue)  
**Points:** 3  
**Epic:** E-001: Rails Foundation  
**Phase:** Phase 0: Rails Foundation & Infrastructure

## Overview

Successfully implemented Sidekiq as the background job processor for the Beaker AI Rails application. Initially used Rails 8.1's built-in SolidQueue, but migrated to Sidekiq for better production stability, mature ecosystem, and superior monitoring capabilities.

## Implementation Summary

### Why Sidekiq Over SolidQueue?

After initial implementation with SolidQueue, the project migrated to Sidekiq because:

- **Production Maturity** - Battle-tested in production environments for over a decade
- **Better Monitoring** - Superior web UI and monitoring tools
- **Community Support** - Larger ecosystem, more gems, better documentation
- **Performance** - More efficient job processing with Redis
- **Cron Jobs** - sidekiq-cron provides robust recurring job scheduling

### What Was Implemented

#### 1. Priority Queue Configuration
- **File:** `config/sidekiq.yml`
- **Queues:** `critical`, `default`, `low` (processed in priority order)
- **Configuration:** 5 threads in dev/test, 10 in production (configurable via `JOB_CONCURRENCY`)
- **Redis:** Connected via `REDIS_URL` environment variable

#### 2. Recurring Jobs with Sidekiq-Cron
- **File:** `config/schedule.yml`
- **Configuration:** Environment-specific cron schedules
- **Initializer:** `config/initializers/sidekiq.rb` loads schedules on server start

#### 3. Enhanced ApplicationJob Base Class
- **File:** `app/jobs/application_job.rb`
- **Retry Logic:** Automatic retry for deadlocks (3 attempts, 5-second wait)
- **Error Handling:** Exponential backoff for network timeouts
- **Graceful Degradation:** Discard jobs with deserialization errors
- **Logging:** Comprehensive job lifecycle logging (start/completion)

#### 4. Test Job Implementation
- **File:** `app/jobs/test_job.rb`
- **Purpose:** Demonstrates job enqueuing and processing
- **Features:** 2-second simulated work, comprehensive logging
- **Queue:** Uses `default` queue for testing

#### 5. Development Process Management
- **File:** `Procfile.dev`
- **Updated:** `worker: bundle exec sidekiq -C config/sidekiq.yml`
- **Result:** `bin/dev` now starts web server, Sidekiq worker, JS, and CSS processes

#### 6. Sidekiq Web UI Monitoring
- **Route:** `http://localhost:3000/sidekiq`
- **Gem:** `sidekiq`
- **Features:** Job monitoring, queue status, retry management, real-time stats
- **Security:** Protected with admin authentication (only admins can access)

#### 7. Comprehensive Test Infrastructure
- **Files:** 
  - `spec/rails_helper.rb` - Sidekiq testing configuration
  - `spec/jobs/test_job_spec.rb` - Job testing specs
- **Coverage:** Job enqueuing, processing, logging verification
- **Mode:** Uses `Sidekiq::Testing.fake!` for reliable testing

#### 8. Application Configuration
- **File:** `config/application.rb`
- **Setting:** `config.active_job.queue_adapter = :sidekiq`
- **Environment:** Test environment uses `:test` adapter for testing
- **Production:** Configured in `config/environments/production.rb`

#### 9. Redis Setup
- **Local:** Redis installed via Homebrew, runs on localhost:6379
- **Heroku:** heroku-redis:mini addon (~$3/month)
- **Connection:** Automatic via `REDIS_URL` environment variable

## Technical Details

### Queue Priority System
```yaml
:queues:
  - critical
  - default  
  - low

production:
  :concurrency: <%= ENV.fetch("JOB_CONCURRENCY", 10).to_i %>
```

### Sidekiq Configuration
```ruby
Sidekiq.configure_server do |config|
  config.redis = { url: ENV.fetch('REDIS_URL', 'redis://localhost:6379/1') }
  
  # Load recurring jobs from schedule.yml
  schedule_file = 'config/schedule.yml'
  if File.exist?(schedule_file) && Sidekiq.server?
    schedule = YAML.load_file(schedule_file)
    # Environment-specific schedule loading
  end
end
```

### Retry Configuration
```ruby
# Deadlock retries
retry_on ActiveRecord::Deadlocked, wait: 5.seconds, attempts: 3

# Network timeout retries with exponential backoff
retry_on Net::OpenTimeout, Net::ReadTimeout, wait: :exponentially_longer, attempts: 3

# Graceful error handling
discard_on ActiveJob::DeserializationError
```

### Job Lifecycle Logging
```ruby
before_perform do |job|
  Rails.logger.info("[Job] Starting #{job.class.name} with args: #{job.arguments.inspect}")
end

after_perform do |job|
  Rails.logger.info("[Job] Completed #{job.class.name}")
end
```

## Testing Verification

### Test Results
```bash
TestJob
  #perform
    enqueues job in default queue
    processes job successfully
    logs job execution

Finished in 4.17 seconds (files took 0.7461 seconds to load)
3 examples, 0 failures
```

### Manual Testing
- ✅ Job enqueuing: `TestJob.perform_later('Hello from Sidekiq!')`
- ✅ Redis verification: Jobs queued in Sidekiq
- ✅ Server startup: Rails server starts without errors
- ✅ Sidekiq Web UI: Accessible at `/sidekiq` route (admin only)

## Files Created

- `app/jobs/test_job.rb` - Test job implementation
- `spec/jobs/test_job_spec.rb` - Job test specifications
- `config/sidekiq.yml` - Sidekiq configuration
- `config/schedule.yml` - Recurring jobs configuration
- `config/initializers/sidekiq.rb` - Sidekiq and cron initialization

## Files Modified

- `config/application.rb` - Active Job adapter set to `:sidekiq`
- `config/environments/production.rb` - Sidekiq adapter configuration
- `config/routes.rb` - Sidekiq Web UI mounting (admin protected)
- `config/environments/test.rb` - Test adapter configuration
- `Procfile.dev` - Worker process updated to Sidekiq
- `Procfile` - Production worker process
- `Gemfile` - Added sidekiq and sidekiq-cron gems
- `spec/rails_helper.rb` - Sidekiq testing configuration
- `app/jobs/application_job.rb` - Enhanced base class
- `env.example` - Added REDIS_URL configuration

## Files Deleted

- `config/queue.yml` - Replaced by sidekiq.yml
- `config/recurring.yml` - Replaced by schedule.yml
- `db/queue_schema.rb` - No longer needed (Redis-backed)

## Database Migration

Created migration to drop all SolidQueue tables:
- `solid_queue_jobs` and related tables removed
- Redis now handles job queuing (no database tables needed)
- Migration: `db/migrate/*_remove_solid_queue_tables.rb`

## Usage Examples

### Enqueuing Jobs
```ruby
# Basic job enqueuing
TestJob.perform_later('Hello World')

# With priority queue
class CriticalJob < ApplicationJob
  queue_as :critical
end

# Scheduled jobs
TestJob.set(wait: 5.minutes).perform_later('Delayed message')
```

### Monitoring Jobs
- Visit `http://localhost:3000/sidekiq` for Sidekiq Web UI (admin only)
- Check Rails logs for job lifecycle events
- Use Sidekiq Web UI for real-time queue monitoring, retries, and stats

### Development Workflow
```bash
# Start all processes (including Sidekiq worker)
bin/dev

# Run tests
bundle exec rspec spec/jobs/

# Start Redis (if not running)
brew services start redis

# Check Sidekiq stats
rails runner "puts Sidekiq::Stats.new.inspect"
```

## Benefits Achieved

1. **Production Maturity** - Battle-tested, decade+ of production use
2. **Superior Monitoring** - Best-in-class web UI with real-time stats
3. **Performance** - Redis-backed, highly efficient job processing
4. **Community** - Large ecosystem, extensive documentation
5. **Cron Jobs** - Built-in recurring job scheduling with sidekiq-cron
6. **Scalability** - Easy horizontal scaling with multiple workers

## Next Steps

The Sidekiq system is now ready for production use. Future enhancements could include:

- Custom job classes for specific business logic (already in place)
- Performance monitoring and alerting via Sidekiq Pro (optional upgrade)
- Job prioritization strategies based on business needs
- Heroku Redis addon provisioning for production deployment

## Conclusion

Successfully delivered a robust, production-ready background job processing system using Sidekiq. After initial implementation with SolidQueue, the migration to Sidekiq provides better stability, monitoring, and community support for long-term production use. The implementation provides a solid foundation for future job processing needs with a mature, well-supported technology stack.
