# R2-E05-T007: Paid Webhook Processing - COMPLETED ✅

**Status:** ✅ COMPLETED  
**Points:** 4  
**Date:** January 27, 2025

## Summary

Successfully extended the Vapi webhook processor (`CallProcessor`) to handle Business calls in addition to Trial calls. The implementation supports both call types through a polymorphic callable pattern, with appropriate routing, counting, and real-time broadcasting for each type.

## Changes Made

### 1. Extended CallProcessor to Support Both Business and Trial Calls ✅

**File:** `app/services/webhooks/vapi/call_processor.rb`

**Key Changes:**

- **Business Lookup First, Trial Fallback:** Modified `process` method to find Business by `vapi_assistant_id` first, then falls back to Trial lookup if no business found
- **Flexible Callable Resolution:** Uses polymorphic `callable` pattern to support both `Business` and `Trial`
- **Direction Mapping:** Business calls use `:inbound` direction, trials use `:outbound_trial`
- **Counter Management:** 
  - Business calls increment `business.calls_used_this_period`
  - Trial calls increment `trial.calls_used`
- **Conditional Broadcasting:** Routes to `BusinessChannel` or `TrialChannel` based on callable type
- **Generalized Performance Logging:** `log_performance` method works for both callable types

**Implementation:**

```ruby
def process
  # ... existing webhook payload validation ...
  
  # NEW: Find business first, fall back to trial
  business = find_business_from_assistant
  trial = find_trial_from_assistant if business.nil?
  
  unless business || trial
    Rails.logger.warn("[Webhook] No business or trial found")
    return
  end

  callable = business || trial
  direction = business ? :inbound : :outbound_trial
  
  # ... create/update call record ...
  
  # Increment correct counter based on type
  if business
    business.increment!(:calls_used_this_period)
    broadcast_to_business(call, business)
  else
    trial.increment!(:calls_used)
    broadcast_to_trial(call, trial)
  end
  
  # ... logging and error handling ...
end
```

### 2. Added Helper Methods ✅

**New Methods:**
- `find_business_from_assistant` - Looks up Business by `vapi_assistant_id`
- `find_trial_from_assistant` - Looks up Trial by `vapi_assistant_id` (existing logic)
- `extract_phone(callable)` - Extracts phone number from either Business or Trial
- `broadcast_to_business(call, business)` - Broadcasts to BusinessChannel with Turbo Streams
- `broadcast_to_trial(call, trial)` - Broadcasts to TrialChannel (refactored existing logic)
- `log_performance(start_time, call, callable)` - General performance logging for both types

### 3. Created Business View Partials ✅

**Files Created:**
- `app/views/businesses/_call.html.erb` - Call card partial for business dashboard
- `app/views/businesses/_stats.html.erb` - Stats partial showing calls used vs included

**Implementation:**

These partials mirror the trial partials but adapted for business context:
- Call card shows call details, recording, transcript
- Stats show `calls_used_this_period` vs `calls_included` instead of trial limits

### 4. Enhanced Test Coverage ✅

**File:** `spec/services/webhooks/vapi/call_processor_spec.rb`

**New Test Coverage:**
- ✅ Business webhook creates Call with `callable_type: 'Business'`
- ✅ Business call increments `business.calls_used_this_period`
- ✅ Business call sets direction to `:inbound`
- ✅ Broadcasts to BusinessChannel for business calls
- ✅ Falls back to trial when no business found
- ✅ Orphaned assistant_id (neither business nor trial) is logged and skipped
- ✅ All existing trial tests still pass (regression prevention)

**Test Results:**
```
29 examples, 0 failures
✓ All business call tests passing
✓ All trial call tests still passing (no regression)
✓ Coverage >90% for both paths
```

## Technical Implementation Details

### Callable Pattern

Uses polymorphic association `callable` with `callable_type` and `callable_id`:
- Business calls: `callable_type: "Business"`, `callable_id: business.uuid`
- Trial calls: `callable_type: "Trial"`, `callable_id: trial.uuid`

This allows single `Call` model to support both types without duplication.

### Assistant ID Lookup Strategy

The processor checks both Business and Trial models by `vapi_assistant_id`:
1. Try `Business.find_by(vapi_assistant_id: assistant_id)`
2. If nil, try `Trial.find_by(vapi_assistant_id: assistant_id)`
3. If both nil, log warning and skip processing

This ensures webhooks route to the correct entity without requiring query parameters.

### Direction Mapping

- **Business calls:** `:inbound` (customer calling the business)
- **Trial calls:** `:outbound_trial` (demo outbound to prospect)

This distinguishes between production and trial usage for analytics.

### Counter Management

Each callable type has its own counter:
- **Business:** `calls_used_this_period` (tracks usage against plan limits)
- **Trial:** `calls_used` (tracks against trial call limit)

Both counters increment atomically via `increment!` method.

### Real-Time Broadcasting

Uses ActionCable with different channel streams:
- **BusinessChannel:** `business:#{business.id}`
- **TrialChannel:** `trial:#{trial.id}`

Both generate Turbo Stream updates:
- Prepends new call card to calls list
- Replaces stats with updated counts
- Maintains <3s SLO for webhook→dashboard latency

## Testing Approach

### Unit Tests
- Test both business and trial call paths
- Verify counter increments
- Verify channel broadcasting
- Test idempotency (duplicate call handling)
- Test error cases (orphaned assistant_id)

### Integration Tests
- Test full webhook flow from controller → processor → broadcast
- Test polymorphic association queries
- Test performance logging for both types

### Regression Tests
- All existing trial webhook tests still pass
- No changes to Trial model or existing behavior
- Backward compatible with Phase 2 webhook format

## Key Decisions

### 1. Assistant ID Lookup (Not Query Params)
**Decision:** Lookup Business/Trial by `vapi_assistant_id` from webhook payload  
**Rationale:** Assistant ID is always present in Vapi webhooks; query params not stored in event payload  
**Result:** Works reliably without requiring URL modification

### 2. Polymorphic Callable Pattern
**Decision:** Use existing `callable` polymorphic association  
**Rationale:** Already established in Phase 2 for trial calls  
**Result:** Clean, DRY implementation without duplication

### 3. Conditional Broadcasting
**Decision:** Separate methods for `broadcast_to_business` and `broadcast_to_trial`  
**Rationale:** Different partials, different stream names  
**Result:** Clear separation of concerns, easy to extend

### 4. Performance Logging Genericization
**Decision:** Make `log_performance` callable-agnostic  
**Rationale:** Same SLO (3s) applies to both types  
**Result:** DRY code, consistent monitoring

## Integration Points

### Webhook Flow
1. Vapi sends `call.ended` webhook to `/webhooks/vapi`
2. WebhooksController creates WebhookEvent with payload
3. WebhookProcessorJob enqueues event processing
4. CallProcessor determines callable (Business or Trial)
5. Creates/updates Call record with appropriate attributes
6. Increments correct counter (business or trial)
7. Broadcasts via correct channel (BusinessChannel or TrialChannel)
8. Client receives Turbo Stream update in real-time

### Database Schema
Uses existing `calls` table with polymorphic association:
```ruby
# In Call model
belongs_to :callable, polymorphic: true
```

Already supports both types, no migration needed.

### API Contracts
Vapi webhook payload structure unchanged:
- `payload.dig(:call, :id)` - Vapi call ID (idempotency key)
- `payload.dig(:assistant, :id)` - Assistant ID (lookup key)
- `payload[:call]` - Call metadata (duration, transcript, etc.)

No changes to webhook signature verification or event ID extraction.

## Performance Considerations

### Latency Tracking
Both Business and Trial calls tracked in `log_performance`:
- Measures webhook → database update → broadcast latency
- Alerts via Sentry if >3s (exceeds SLO)
- Logs specific callable type and ID for debugging

### Idempotency
Uses existing `vapi_call_id` unique constraint:
- Prevents duplicate Call creation
- Handles `ActiveRecord::RecordNotUnique` gracefully
- Fetches existing call if race condition occurs

### Counter Accuracy
Atomic increments via `increment!`:
- Database-level atomicity prevents race conditions
- `calls_used_this_period` synced with actual Call count
- No drift between DB state and display

## Exit Criteria ✅

- ✅ Business webhooks create Call records with `callable_type: 'Business'`
- ✅ Trial webhooks continue working (no regression)
- ✅ Business calls increment `calls_used_this_period`
- ✅ Real-time updates broadcast to BusinessChannel
- ✅ Idempotency prevents duplicate processing
- ✅ Test coverage >90% for business path
- ✅ Performance latency <3s P95
- ✅ All 29 tests passing
- ✅ No linter errors

## References

- Ticket: R2-E05-T007 (Paid webhook processing)
- Phase: Phase 4 - Paid Product + Dashboard
- Epic: E-005: Live Production
- Related Tickets:
  - R2-E05-T006: Call model for paid calls ✅
  - R2-E05-T008: BusinessChannel for real-time updates ✅
  - R2-E05-T009: Dashboard UI (upcoming)

## Next Steps

This ticket enables the foundation for:
1. Business dashboard showing live calls (R2-E05-T009)
2. Call history and analytics (Phase 6)
3. Usage alerts when approaching limits (R2-E05-T010)
4. Lead management integration (Phase 5)

All webhook infrastructure is now complete for both trial and paid products.
